% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/impute.R
\name{impute}
\alias{impute}
\title{Impute with RGCCA method}
\usage{
impute(
  blocks,
  connection,
  tau,
  ni = 50,
  tol = 1e-08,
  ncomp = NULL,
  naxis = 1,
  scale = TRUE,
  scale_block = TRUE,
  scheme = "centroid",
  bias = TRUE,
  superblock = FALSE,
  verbose = FALSE,
  threshold = 0.001,
  reg = "y",
  quiet = FALSE
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables
\eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}{X1, X2, ..., XJ}.
Block \eqn{\mathbf{X}_j}{Xj} is a matrix of dimension
\eqn{n \times p_j}{n x p_j} where n is the number of
observations and \eqn{p_j} the number of variables.}

\item{connection}{A symmetric matrix (\eqn{J \times J}{J x J}) that
describes the relationships between blocks.}

\item{tau}{Either a \eqn{1 \times J}{1 x J} vector or a
\eqn{\mathrm{max}(ncomp) \times J}{max(ncomp) x J} matrix containing
the values of the regularization parameters (default: tau = 1, for each
block and each dimension). The regularization parameters varies from 0
(maximizing the correlation) to 1 (maximizing the covariance). If
tau = "optimal" the regularization parameters are estimated for each block
and each dimension using the Schafer and Strimmer (2005) analytical formula.
If tau is a \eqn{1 \times J}{1 x J} vector, tau[j] is identical across the
dimensions of block \eqn{\mathbf{X}_j}{Xj}. If tau is a matrix, tau[k, j]
is associated with \eqn{\mathbf{X}_{jk}}{Xjk} (kth residual matrix for
block j). The regularization parameters can also be estimated using
\link{rgcca_permutation} or \link{rgcca_cv}.}

\item{ni}{An integer for the maximal number of iterations before convergence}

\item{tol}{The stopping value for the convergence of the algorithm.}

\item{ncomp}{Vector of length J indicating the number of block components
for each block.}

\item{naxis}{number of component to select for the estimation of missing data}

\item{scale}{TRUE if the variables should be standardized, FALSE ifelse}

\item{scale_block}{scaling of the blocks: "lambda1" for the first eigen value
of the block (as in MFA)  or "inertia" for the sum of eigenvalues (when
scale=TRUE, equivalent to divide by sqrt(p_j)).}

\item{scheme}{Character string or a function giving the scheme function for
covariance maximization among "horst" (the identity function), "factorial"
 (the squared values), "centroid" (the absolute values). The scheme function
 can be any continously differentiable convex function and it is possible to
 design explicitely the scheme function (e.g. function(x) x^4) as argument of
 rgcca function.  See (Tenenhaus et al, 2017) for details.}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{superblock}{Boolean indicating the presence of the superblock.
Default = TRUE}

\item{verbose}{FALSE by default. If TRUE, displays results of convergence for
each iteration}

\item{threshold}{threshold to be reached to assess convergence.}

\item{reg}{'y' by default. Reconstruction is made by regression of the blocks
rows on w ('w'),the blocks columns on Y ('y')  or without any regression
with y ('no')}

\item{quiet}{Logical value indicating if warning messages are reported.}
}
\value{
\item{blocks}{blocks list of imputed matrices giving the \eqn{J}
 blocks of variables \eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}}

\item{stab}{Convergence criterion : abs(1-obj_k/obj_{k-1})}

\item{obj}{Vector containing the mean square error between the
 predict values and the original non missing values at each iteration}

\item{crit}{RGCCA criterion}

\item{indNA}{Position of missing values}
}
\description{
This method is used for the implementation of EM algorithm for missing data
}
