% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/rgcca_permutation.R
\name{rgcca_permutation}
\alias{rgcca_permutation}
\title{Tune the S/RGCCA hyper-parameters by permutation}
\usage{
rgcca_permutation(
  blocks,
  par_type = "tau",
  par_value = NULL,
  par_length = 10,
  n_perms = 20,
  n_cores = 1,
  quiet = TRUE,
  scale = TRUE,
  scale_block = TRUE,
  method = "rgcca",
  connection = NULL,
  scheme = "factorial",
  ncomp = 1,
  tau = 1,
  sparsity = 1,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  NA_method = "nipals",
  rgcca_res = NULL,
  verbose = TRUE,
  n_iter_max = 1000,
  comp_orth = TRUE
)
}
\arguments{
\item{blocks}{A list that contains the J blocks of variables
\eqn{\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}}{X1, X2, ..., XJ}.
Block \eqn{\mathbf{X}_j}{Xj} is a matrix of dimension
\eqn{n \times p_j}{n x p_j} where n is the number of
observations and \eqn{p_j} the number of variables.}

\item{par_type}{A character string indicating the parameters to tune between
"sparsity" and "tau".}

\item{par_value}{Sets of penalties to consider during the permutation
process.
If par_value = NULL, it takes 10 sets between min values (0 for RGCCA and
1/sqrt(ncol(Xj)) for SGCCA) and 1. Otherwise, it could be either (i) A matrix
of dimension IxJ (where I the number of combinations to be tested and J the
number of blocks), or (ii) a vector of length J length specifying the maximal
values to consider for each block. In that case, par_length combinations
are tested from min values to the maximal values specified by this vector.
(iii) a numerical value giving the same maximal value to be considered for
each block. In that case par_length combinations are tested from min values
to this single maximal value.}

\item{par_length}{A numeric value indicating the number of sets of penalties
to be tested (if par_value = NULL).}

\item{n_perms}{The number of permutations for each set of constraints (default
is 20).}

\item{n_cores}{The number of cores used for parallelization.}

\item{quiet}{A logical value indicating if warning messages are reported.}

\item{scale}{A logical value indicating if variables are standardized.}

\item{scale_block}{A value indicating if each block is scaled. If TRUE or
"inertia", each block is divided by the sum of eigenvalues of its empirical
covariance matrix. If "lambda1", each block is divided by the square root of
the highest eigenvalue of its empirical covariance matrix. Otherwise the
blocks are not scaled. If standardization is applied (scale = TRUE), the
block scaling applies on the standardized blocks.}

\item{method}{A string specifying which multiblock component
method to consider. Possible values are found using \link{available_methods}}

\item{connection}{A symmetric matrix (\eqn{J \times J}{J x J}) describing
the network of connections between blocks (default value: 1-diag(J)).}

\item{scheme}{A string or a function specifying the scheme function applied to
covariance maximization among "horst" (the identity function), "factorial"
 (the square function - default value), "centroid" (the absolute value
 function). The scheme function can be any continously differentiable convex
 function and it is possible to design explicitely the scheme function
 (e.g. function(x) x^4) as argument of the function.  See (Tenenhaus et al,
 2017) for details.}

\item{ncomp}{A vector of length J indicating the number of components
per block.}

\item{tau}{Either a numeric vector of size \eqn{1 \times J}{1 x J}, a
numeric matrix of dimension \eqn{\mathrm{max}(ncomp) \times J}{max(ncomp) x J}
containing the values of the regularization parameters (default: tau = 1, for each
block and each dimension) or a string equal to "optimal". If tau is a vector,
tau[j] is identical across the dimensions of block \eqn{\mathbf{X}_j}{Xj}.
If tau is a matrix, tau[k, j] is associated with the kth dimension of block j.
The regularization parameters varies from 0 (maximizing the correlation) to
1 (maximizing the covariance). If tau = "optimal" the regularization
parameters are estimated for each block and each dimension using the Schafer
and Strimmer (2005) analytical formula. The regularization parameters can
also be estimated using \link{rgcca_permutation} or \link{rgcca_cv}.}

\item{sparsity}{Either a numeric vector of size \eqn{1*J} or a numeric matrix
of dimension \eqn{max(ncomp) * J} encoding the L1 constraints applied to the
block weight vectors. For block j, the amount of sparsity varies between
\eqn{1/sqrt(p_j)} and 1 (larger values of sparsity correspond to less
penalization).

If sparsity is a vector, sparsity[j] is identical across the dimensions
h = 1, ..., H of block j:
\deqn{for all h, |a_{j,h}|_{L_1} \le sparsity[j] \sqrt{p_j},}
with \eqn{p_j} the number of variables of \eqn{X_j}.

If sparsity is a matrix, sparsity[h, j] is associated with the hth dimension
of block j:
\deqn{for all h, |a_{j,h}|_{L_1} \le sparsity[h,j] \sqrt{p_j}.}
sparsity can be estimated by using \link{rgcca_permutation} or \link{rgcca_cv}.}

\item{init}{A string giving the type of initialization to use in
the RGCCA algorithm. It could be either by Singular Value Decompostion ("svd")
or by random initialisation ("random") (default: "svd").}

\item{bias}{A logical value for biaised (\eqn{1/n}) or unbiaised
(\eqn{1/(n-1)}) estimator of the var/cov (default: bias = TRUE).}

\item{tol}{The stopping value for the convergence of the algorithm
(default: tol = 1e-08).}

\item{response}{Numerical value giving the position of the response block.
When the response argument is filled the supervised mode is automatically
activated.}

\item{superblock}{A logical value indicating if the superblock option is used.}

\item{NA_method}{A string indicating the method used for
handling missing values ("nipals", "complete"). (default: "nipals").
\itemize{
\item{\code{"complete"}}{corresponds to perform RGCCA on the fully observed
observations (observations with missing values are removed)}
\item{\code{"nipals"}}{corresponds to perform RGCCA algorithm on available
data (NIPALS-type algorithm)}}}

\item{rgcca_res}{A fitted RGCCA object (see  \code{\link[RGCCA]{rgcca}})}

\item{verbose}{A logical value indicating if the progress of the
permutation procedure is reported.}

\item{n_iter_max}{Integer giving the algorithm's maximum number of
iterations.}

\item{comp_orth}{A logical value indicating if the deflation should lead to
orthogonal components or orthogonal weights.}
}
\value{
\item{opt}{A list indicating some options of the RGCCA model used
during the permutation.}

\item{call}{A list containing the input parameters}

\item{par_type}{A character string indicating the parameters to tune
between "sparsity" and "tau".}

\item{n_perms}{The number of permutations for each set of candidate
tuning paramaters (default
is 20)}

\item{bestpenalties}{The set of tuning parameters that yields the
highest Z-statistic}

\item{permcrit}{A matrix of permuted S/RGCCA criteria. The ith row of
permcrit contains the n_perms values of S/RGCCA permuted criteria
obtained for each set of tuning parameters.}

\item{penalties}{A matrix giving, the set of candidate tuning
paramaters considered during the permutation process (tau or sparsity).}

\item{stats}{A data.frame containing in column: the set of candidate
parameters, the corresponding non permuted criterion, mean and standard
deviation of permuted criteria, Z-statistic and p-value.}
}
\description{
This function can be used to automatically select the hyper-parameters
(amount of sparsity for sgcca or shrinkage parameters for RGCCA).
A permutation based strategy very similar to the one proposed in
(Witten et al, 2009) is implemented.
}
\details{
The tuning parameters are selected using the permutation scheme proposed in
(Witten et al, 2009). For each candidate tuning parameter value, the
following is performed:

(1) Repeat the following n_perms times (for n_perms large): \cr
   \verb{    }(a) The samples in \eqn{X_1},..., \eqn{X_J} are randomly
   permuted blocks: \eqn{X_1^*},..., \eqn{X_J^*}. \cr
   \verb{    }(b) S/RGCCA is run on the permuted data sets \eqn{X_1^*},...,
      \eqn{X_J^*} to get canonical variates \eqn{a_1^*},..., \eqn{a_J^*}.\cr
   \verb{    }(c) Record t* = sum_(j,k) c_jk g(Cov(X_j^*a_j^*, X_k^*a_k^*).

(2) Sparse CCA is run on the blocks \eqn{X_1},..., \eqn{X_J} to obtain
    canonical variates \eqn{a_1},..., \eqn{a_J}.

(3) Record t = sum_(j,k) c_jk g(Cov(X_ja_j, X_ka_k).

(4) The resulting p-value is given by $mean(t* > t)$; that is, the fraction
of t* that exceed the value of t obtained from the real data.

Then, choose the tuning parameter values that gives the smallest value in
Step 4.

This function only selects tuning parameters for the first deflation stage
of S/RGCCA. By default, this function performs a one-dimensional
search in tuning parameter space.
}
\examples{
####################################
# Permutation based strategy for   #
# determining the best shrinkage   #
# parameters (par_type = "tau")    #
####################################

data(Russett)
blocks <- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)

C <- matrix(c(
  0, 0, 1,
  0, 0, 1,
  1, 1, 0
), 3, 3)

# default value: 10 vectors from rep(0, length(blocks))
# to rep(1, length(blocks)), uniformly distributed.

fit <- rgcca_permutation(blocks,
  connection = C,
  par_type = "tau",
  par_length = 10, n_perms = 2,
  n_cores = 1
)

print(fit)
plot(fit)
fit$bestpenalties

\dontrun{
# It is possible to define explicitly K combinations of shrinkage
# parameters to be tested and in that case a matrix of dimension KxJ is
# required. Each row of this matrix corresponds to one specific set of
# shrinkage parameters.
par_value <- matrix(c(
  0, 0, 0,
  1, 1, 0,
  0.5, 0.5, 0.5,
  sapply(blocks, RGCCA:::tau.estimate),
  1, 1, 1
), 5, 3, byrow = TRUE)


perm.out <- rgcca_permutation(blocks,
  connection = C,
  par_type = "tau",
  par_value = par_value,
  n_perms = 5, n_cores = 1
)

print(perm.out)
plot(perm.out)

# with superblock

perm.out <- rgcca_permutation(blocks,
  par_type = "tau",
  superblock = TRUE,
  scale = TRUE, scale_block = FALSE,
  n_perms = 5, n_cores = 1
)

print(perm.out)
plot(perm.out)

# used a fitted rgcca_permutation object as input of the rgcca function
fit.rgcca <- rgcca(perm.out)
fit.rgcca$call$tau
fit.rgcca$call$scale
fit.rgcca$call$scale_block

######################################
# Permutation based strategy for     #
# determining the best sparsity      #
# parameters (par_type = "sparsity") #
######################################

# defaut value: 10 vectors from minimum values
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ))
# to rep(1, J), uniformly distributed.

perm.out <- rgcca_permutation(blocks,
  par_type = "sparsity",
  n_perms = 50, n_cores = 1
)

print(perm.out)
plot(perm.out)
perm.out$bestpenalties

# when par_value is a vector of length J. Each element of the vector
# indicates the maximum value of sparsity to be considered for each block.
# par_length (default value = 10) vectors from minimum values
# (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ)) to maximum values, uniformly
# distributed, are then considered.

perm.out <- rgcca_permutation(blocks,
  connection = C,
  par_type = "sparsity",
  par_value = c(0.6, 0.75, 0.5),
  par_length = 7, n_perms = 20,
  n_cores = 1, tol = 1e-3
)

print(perm.out)
plot(perm.out)
perm.out$bestpenalties

# when par_value is a scalar, the same maximum value is applied
# for each block

perm.out <- rgcca_permutation(blocks,
  connection = C,
  par_type = "sparsity",
  par_value = 0.8, par_length = 5,
  n_perms = 10, n_cores = 1
)

perm.out$penalties

######################################
# speed up the permutation procedure #
######################################

# The rgcca_permutation function can be quite time-consuming. Since
# approximate estimates of the block weight vectors are acceptable in this
# case, it is possible to reduce the value of the tolerance (tol argument)
# of the RGCCA algorithm to speed up the permutation procedure.
#
data("ge_cgh_locIGR", package = "gliomaData")
A <- ge_cgh_locIGR$multiblocks
Loc <- factor(ge_cgh_locIGR$y)
levels(Loc) <- colnames(ge_cgh_locIGR$multiblocks$y)
A[[3]] <- A[[3]][, -3]
C <- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)

# check dimensions of the blocks
sapply(A, dim)

par_value <- matrix(c(
  seq(0.1, 1, by = 0.1),
  seq(0.1, 1, by = 0.1),
  rep(0, 10)
), 10, 3, byrow = FALSE)

fit <- rgcca_permutation(A,
  connection = C,
  par_type = "tau",
  par_value = par_value,
  par_length = 10,
  n_perms = 10, n_cores = 1, tol = 1e-2
)
print(fit)
plot(fit)
}

}
\references{
Witten, D. M., Tibshirani, R., & Hastie, T. (2009). A penalized
matrix decomposition, with applications to sparse principal components and
canonical correlation analysis. Biostatistics, 10(3), 515-534.
}
